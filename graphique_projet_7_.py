# -*- coding: utf-8 -*-
"""graphique projet 7 .ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zUlMC2Fzb2Mhl2sWGIg88hnQsB2LC1fX
"""


import numpy as np
import pandas as pd
import gc
import time
from contextlib import contextmanager
from lightgbm import LGBMClassifier
import lightgbm as lgb

from sklearn.datasets import make_classification
from sklearn.metrics import roc_auc_score, roc_curve, f1_score, fbeta_score, precision_score, recall_score, make_scorer, confusion_matrix, classification_report, accuracy_score
from sklearn.model_selection import KFold, StratifiedKFold, GridSearchCV, train_test_split
from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
from catboost import CatBoostClassifier, Pool
import tensorflow as tf
from imblearn.over_sampling import SMOTE
import lime
import lime.lime_tabular
import mlflow
import streamlit as st
import os
import shutil
import logging
import shap

from sklearn.pipeline import Pipeline
from sklearn.dummy import DummyClassifier
from imblearn.pipeline import Pipeline as ImbPipeline
from sklearn.datasets import make_classification
from sklearn.metrics import classification_report
from xgboost import XGBClassifier

# Disable warnings
warnings.simplefilter(action='ignore', category=FutureWarning)

# Mount Google Drive
from google.colab import drive
drive.mount('/content/drive')

# Check available GPUs
print("Num GPUs Available:", len(tf.config.list_physical_devices('GPU')))

# Disable logging
logging.disable(logging.WARNING)

data = pd.read_csv('/content/drive/My Drive/projet_7/kaggle7.csv')

data

df = df.dropna(axis=1)
df

"""Entrainement modele"""

X = df.drop('TARGET', axis=1)
y = df['TARGET']

from sklearn.model_selection import train_test_split
from xgboost import XGBClassifier
from imblearn.over_sampling import SMOTE
from sklearn.pipeline import Pipeline
from sklearn.metrics import classification_report
from imblearn.pipeline import Pipeline as ImbPipeline

# Diviser les données en ensembles d'entraînement et de test
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Définir le modèle XGBoost
xgb_model = XGBClassifier(random_state=42, n_estimators=100, max_depth=3)

# Créer une sous-pipeline avec SMOTE
sub_pipeline = ImbPipeline([
    ('smote', SMOTE(random_state=42)),
    ('model', xgb_model)
])

# Créer le pipeline global
pipeline = Pipeline([
    ('sub_pipeline', sub_pipeline)
])

# Entraîner le modèle sur les données d'entraînement
pipeline.fit(X_train, y_train)

# Faire des prédictions sur les données de test
y_pred = pipeline.predict(X_test)

# Générer un rapport de classification
classification_rep = classification_report(y_test, y_pred)
print("Rapport de classification :\n", classification_rep)

"""Box client"""

import pandas as pd
import streamlit as st


# Titre de l'application
st.title("Informations sur les clients")

# Sélectionnez un numéro de client à l'aide d'un widget de sélection
selected_client = st.selectbox("Sélectionnez un numéro de client :", df['SK_ID_CURR'])

# Sélectionnez les colonnes à afficher à l'aide d'un widget de sélection multiple
selected_columns = st.multiselect(
    "Sélectionnez les colonnes à afficher :",
    ['AMT_INCOME_TOTAL', 'INCOME_CREDIT_PERC', 'CODE_GENDER']
)

# Affichez les informations du client sélectionné
if selected_client is not None:
    client_data = df[df['SK_ID_CURR'] == selected_client]
    if not client_data.empty:
        st.write("Informations du client sélectionné :")
        st.write(client_data[selected_columns])
    else:
        st.warning("Aucune information trouvée pour ce client.")
else:
    st.info("Sélectionnez un numéro de client dans la liste ci-dessus.")

"""o	Afficher si le crédit accepté ou non avec un graph en jauge


"""

import plotly.graph_objects as go

# Données  pour illustrer l'exemple
n_clients_total = len(df)
n_clients_credit = len(df[df["TARGET"] == 1])

# Calcul du pourcentage de clients avec crédit
pourcentage_credit = (n_clients_credit / n_clients_total) * 100

# Création de la figure de la jauge
fig = go.Figure(go.Indicator(
    mode="gauge+number",
    value=pourcentage_credit,
    title={'text': "Clients avec Crédit"},
    gauge={
        'axis': {'range': [None, 100]},
        'bar': {'color': 'darkblue'},
        'steps': [
            {'range': [0, 50], 'color': 'red'},
            {'range': [50, 100], 'color': 'green'}
        ],
        'threshold': {
            'line': {'color': "black", 'width': 4},
            'thickness': 0.75,
            'value': 70
        }
    }
))

# Affichage de la figure
fig.show()

"""Feature importance"""

import shap
import plotly.graph_objs as go
import plotly.offline as pyo

# Charger les données pour expliquer les prédictions
explainer = shap.Explainer(xgb_model)
shap_values = explainer.shap_values(X_test)

# Sélectionnez l'instance que vous souhaitez visualiser (par exemple, la première instance)
selected_instance = 0

# Obtenir les valeurs SHAP pour l'instance sélectionnée
shap_instance = shap_values[selected_instance]

# Obtenez les noms de colonnes pour vos fonctionnalités
feature_names = X_test.columns  # Assurez-vous que cela correspond à vos noms de colonnes

# Sélectionnez les N fonctionnalités les plus importantes
top_n = 20
top_features_idx = shap_instance.argsort()[-top_n:][::-1]
top_feature_names = feature_names[top_features_idx]
top_shap_values = shap_instance[top_features_idx]

# Créez un graphique à barres pour afficher les N fonctionnalités les plus importantes
bar_chart = go.Bar(x=top_shap_values, y=top_feature_names, orientation='h')

# Créez une mise en page de graphique
layout = go.Layout(
    title=f"Top {top_n} SHAP Values for Instance {selected_instance}",
    xaxis=dict(title="SHAP Value", automargin=True),  # Ajustez la marge automatiquement
    yaxis=dict(title="Feature", tickvals=top_feature_names, tickangle=0, automargin=True)  # Ajustez la marge automatiquement
)

# Créez la figure du graphique
fig = go.Figure(data=[bar_chart], layout=layout)

# Ajustez la taille de la figure pour éviter la troncation des noms de colonnes
fig.update_layout(height=400, width=800, margin=dict(l=100))  # Ajustez la marge gauche (l=100)

# Affichez la figure en utilisant Plotly
pyo.iplot(fig)

